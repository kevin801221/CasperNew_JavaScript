{"ast":null,"code":"/**\n * API 服務工具\n * 用於處理與 remove.bg API 的通信\n */\n\n// remove.bg API 基礎 URL\nconst API_BASE_URL = 'https://api.remove.bg/v1.0';\n\n// API Key - 直接使用硬編碼的方式，確保在開發環境中可以正常使用\nconst API_KEY = 'Khr1wiotNPuDyqQZxpzNKTsZ';\n\n/**\n * 發送去背請求到 remove.bg API\n * @param {File|Blob|string} image - 圖片文件、Blob 或 URL\n * @returns {Promise<string>} 去背後的圖片 Base64 字符串\n */\nexport const removeBackgroundAPI = async image => {\n  try {\n    console.log('開始處理去背請求，圖片類型:', typeof image);\n\n    // 創建 FormData 對象\n    const formData = new FormData();\n\n    // 設置圖片大小參數\n    formData.append('size', 'auto');\n\n    // 根據圖片類型選擇不同的處理方式\n    if (typeof image === 'string') {\n      // 如果是本地檔案路徑，先轉換為完整 URL\n      if (image.startsWith('/') && !image.startsWith('//')) {\n        const origin = window.location.origin;\n        image = `${origin}${image}`;\n      }\n      if (image.startsWith('data:')) {\n        // 如果是 base64 圖片\n        console.log('處理 base64 圖片');\n        formData.append('image_file_b64', image.split(',')[1]);\n      } else if (image.startsWith('http') || image.startsWith('//')) {\n        // 如果是 URL\n        console.log('處理 URL 圖片:', image);\n        formData.append('image_url', image);\n      } else {\n        console.error('不支持的圖片格式:', image);\n        throw new Error('不支持的圖片格式');\n      }\n    } else if (image instanceof Blob || image instanceof File) {\n      // 如果是 Blob 或 File 對象\n      console.log('處理 Blob/File 圖片');\n      formData.append('image_file', image);\n    } else {\n      console.error('不支持的圖片類型:', image);\n      throw new Error('不支持的圖片類型');\n    }\n    console.log('發送請求到 remove.bg API');\n\n    // 發送請求到 remove.bg API\n    const response = await fetch(`${API_BASE_URL}/removebg`, {\n      method: 'POST',\n      headers: {\n        'X-Api-Key': API_KEY\n      },\n      body: formData\n    });\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error(`API 請求失敗: ${response.status} ${response.statusText}`, errorText);\n      throw new Error(`API 請求失敗: ${response.status} ${response.statusText}`);\n    }\n    console.log('API 請求成功，正在處理響應');\n\n    // 獲取二進制數據\n    const arrayBuffer = await response.arrayBuffer();\n\n    // 轉換為 base64\n    const base64 = arrayBufferToBase64(arrayBuffer);\n    console.log('去背處理完成，返回 base64 圖片');\n    return `data:image/png;base64,${base64}`;\n  } catch (error) {\n    console.error('去背 API 調用失敗:', error);\n    throw error;\n  }\n};\n\n/**\n * 將 ArrayBuffer 轉換為 base64 字符串\n * @param {ArrayBuffer} buffer - 要轉換的 ArrayBuffer\n * @returns {string} base64 字符串（不包含 data URL 前綴）\n */\nconst arrayBufferToBase64 = buffer => {\n  try {\n    let binary = '';\n    const bytes = new Uint8Array(buffer);\n    const len = bytes.byteLength;\n    for (let i = 0; i < len; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    return window.btoa(binary);\n  } catch (error) {\n    console.error('轉換 ArrayBuffer 到 base64 失敗:', error);\n    throw error;\n  }\n};\n\n/**\n * 發送批量去背請求到 API\n * @param {Array<File|Blob|string>} images - 圖片文件、Blob 或 URL 的數組\n * @returns {Promise<Array<string>>} 去背後的圖片 Base64 數組\n */\nexport const batchRemoveBackgroundAPI = async images => {\n  try {\n    // remove.bg 不直接支持批量處理，所以我們並行處理多個請求\n    // 為了避免同時發送太多請求，我們使用 Promise.all 但限制並行數\n    const batchSize = 3; // 每批處理的圖片數量\n    const results = [];\n\n    // 分批處理\n    for (let i = 0; i < images.length; i += batchSize) {\n      const batch = images.slice(i, i + batchSize);\n      const batchPromises = batch.map(image => removeBackgroundAPI(image));\n\n      // 等待當前批次完成\n      const batchResults = await Promise.all(batchPromises);\n      results.push(...batchResults);\n\n      // 如果還有更多圖片要處理，添加延遲以避免 API 限制\n      if (i + batchSize < images.length) {\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n    }\n\n    // 返回處理後的圖片 URL 數組\n    return results;\n  } catch (error) {\n    console.error('批量去背 API 調用失敗:', error);\n    throw error;\n  }\n};\n\n/**\n * 發送背景替換請求到 API\n * @param {File|Blob|string} image - 圖片文件、Blob 或 URL\n * @param {File|Blob|string} background - 背景圖片文件、Blob 或 URL\n * @returns {Promise<string>} 處理後的圖片 URL\n */\nexport const replaceBackgroundAPI = async (image, background) => {\n  try {\n    // 首先去除背景\n    const transparentImage = await removeBackgroundAPI(image);\n\n    // 將透明背景的圖片轉換為 Blob\n    const response = await fetch(transparentImage);\n    const imageBlob = await response.blob();\n\n    // 使用 Canvas 合成新圖片\n    const compositeImage = await compositeImages(imageBlob, background);\n    return compositeImage;\n  } catch (error) {\n    console.error('背景替換 API 調用失敗:', error);\n    throw error;\n  }\n};\n\n/**\n * 使用 Canvas 將兩張圖片合成\n * @param {Blob} foreground - 前景圖片（已去背）\n * @param {string} background - 背景圖片 URL\n * @returns {Promise<string>} 合成後的圖片 base64 字符串\n */\nconst compositeImages = async (foreground, background) => {\n  return new Promise(async (resolve, reject) => {\n    try {\n      console.log('開始合成圖片...');\n      console.log('前景圖片類型:', typeof foreground);\n      console.log('背景圖片類型:', typeof background);\n\n      // 創建兩個 Image 對象\n      const fgImage = new Image();\n      const bgImage = new Image();\n\n      // 設置跨域屬性\n      fgImage.crossOrigin = 'anonymous';\n      bgImage.crossOrigin = 'anonymous';\n\n      // 加載前景圖片\n      fgImage.onload = () => {\n        console.log('前景圖片加載成功，尺寸:', fgImage.width, 'x', fgImage.height);\n\n        // 前景加載完成後，加載背景\n        try {\n          if (typeof background === 'string') {\n            if (background.startsWith('data:')) {\n              console.log('加載 data URL 背景');\n              bgImage.src = background;\n            } else if (background.startsWith('http') || background.startsWith('//')) {\n              console.log('加載網絡背景 URL:', background);\n              // 使用代理服務來避免 CORS 問題\n              const proxyUrl = `https://cors-anywhere.herokuapp.com/${background}`;\n              bgImage.src = proxyUrl;\n            } else {\n              console.log('加載本地背景 URL');\n              bgImage.src = background;\n            }\n          } else if (background instanceof Blob || background instanceof File) {\n            console.log('加載 Blob/File 背景');\n            bgImage.src = URL.createObjectURL(background);\n          } else {\n            throw new Error('不支持的背景圖片類型');\n          }\n        } catch (err) {\n          console.error('加載背景圖片時出錯:', err);\n          reject(err);\n        }\n      };\n\n      // 背景加載完成後，進行合成\n      bgImage.onload = () => {\n        console.log('背景圖片加載成功，尺寸:', bgImage.width, 'x', bgImage.height);\n        try {\n          // 創建 Canvas 元素\n          const canvas = document.createElement('canvas');\n          const ctx = canvas.getContext('2d');\n\n          // 設置 Canvas 尺寸為前景圖片的尺寸\n          canvas.width = fgImage.width;\n          canvas.height = fgImage.height;\n          console.log('Canvas 尺寸設置為:', canvas.width, 'x', canvas.height);\n\n          // 繪製背景（調整大小以適應 Canvas）\n          ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);\n          console.log('背景已繪製到 Canvas');\n\n          // 繪製前景\n          ctx.drawImage(fgImage, 0, 0, canvas.width, canvas.height);\n          console.log('前景已繪製到 Canvas');\n\n          // 轉換為 base64\n          const result = canvas.toDataURL('image/png');\n          console.log('合成完成，結果長度:', result.length);\n\n          // 如果背景是 Blob URL，釋放它\n          if (background instanceof Blob || background instanceof File) {\n            URL.revokeObjectURL(bgImage.src);\n          }\n\n          // 如果前景是 Blob URL，釋放它\n          if (foreground instanceof Blob) {\n            URL.revokeObjectURL(fgImage.src);\n          }\n          resolve(result);\n        } catch (err) {\n          console.error('合成圖片時出錯:', err);\n          reject(err);\n        }\n      };\n\n      // 設置錯誤處理\n      fgImage.onerror = err => {\n        console.error('加載前景圖片失敗:', err);\n        reject(new Error('加載前景圖片失敗'));\n      };\n      bgImage.onerror = err => {\n        console.error('加載背景圖片失敗:', err);\n        reject(new Error('加載背景圖片失敗'));\n      };\n\n      // 開始加載前景\n      try {\n        console.log('開始加載前景圖片...');\n        if (foreground instanceof Blob) {\n          console.log('加載 Blob 前景');\n          fgImage.src = URL.createObjectURL(foreground);\n        } else if (typeof foreground === 'string') {\n          console.log('加載字符串前景:', foreground.substring(0, 50) + '...');\n          fgImage.src = foreground;\n        } else {\n          throw new Error('不支持的前景圖片類型');\n        }\n      } catch (err) {\n        console.error('設置前景圖片時出錯:', err);\n        reject(err);\n      }\n    } catch (error) {\n      console.error('合成圖片過程中出錯:', error);\n      reject(error);\n    }\n  });\n};","map":{"version":3,"names":["API_BASE_URL","API_KEY","removeBackgroundAPI","image","console","log","formData","FormData","append","startsWith","origin","window","location","split","error","Error","Blob","File","response","fetch","method","headers","body","ok","errorText","text","status","statusText","arrayBuffer","base64","arrayBufferToBase64","buffer","binary","bytes","Uint8Array","len","byteLength","i","String","fromCharCode","btoa","batchRemoveBackgroundAPI","images","batchSize","results","length","batch","slice","batchPromises","map","batchResults","Promise","all","push","resolve","setTimeout","replaceBackgroundAPI","background","transparentImage","imageBlob","blob","compositeImage","compositeImages","foreground","reject","fgImage","Image","bgImage","crossOrigin","onload","width","height","src","proxyUrl","URL","createObjectURL","err","canvas","document","createElement","ctx","getContext","drawImage","result","toDataURL","revokeObjectURL","onerror","substring"],"sources":["/Users/kevinluo/application/Casper_final_version/react-frontend/src/utils/apiService.js"],"sourcesContent":["/**\n * API 服務工具\n * 用於處理與 remove.bg API 的通信\n */\n\n// remove.bg API 基礎 URL\nconst API_BASE_URL = 'https://api.remove.bg/v1.0';\n\n// API Key - 直接使用硬編碼的方式，確保在開發環境中可以正常使用\nconst API_KEY = 'Khr1wiotNPuDyqQZxpzNKTsZ';\n\n/**\n * 發送去背請求到 remove.bg API\n * @param {File|Blob|string} image - 圖片文件、Blob 或 URL\n * @returns {Promise<string>} 去背後的圖片 Base64 字符串\n */\nexport const removeBackgroundAPI = async (image) => {\n  try {\n    console.log('開始處理去背請求，圖片類型:', typeof image);\n    \n    // 創建 FormData 對象\n    const formData = new FormData();\n    \n    // 設置圖片大小參數\n    formData.append('size', 'auto');\n    \n    // 根據圖片類型選擇不同的處理方式\n    if (typeof image === 'string') {\n      // 如果是本地檔案路徑，先轉換為完整 URL\n      if (image.startsWith('/') && !image.startsWith('//')) {\n        const origin = window.location.origin;\n        image = `${origin}${image}`;\n      }\n      \n      if (image.startsWith('data:')) {\n        // 如果是 base64 圖片\n        console.log('處理 base64 圖片');\n        formData.append('image_file_b64', image.split(',')[1]);\n      } else if (image.startsWith('http') || image.startsWith('//')) {\n        // 如果是 URL\n        console.log('處理 URL 圖片:', image);\n        formData.append('image_url', image);\n      } else {\n        console.error('不支持的圖片格式:', image);\n        throw new Error('不支持的圖片格式');\n      }\n    } else if (image instanceof Blob || image instanceof File) {\n      // 如果是 Blob 或 File 對象\n      console.log('處理 Blob/File 圖片');\n      formData.append('image_file', image);\n    } else {\n      console.error('不支持的圖片類型:', image);\n      throw new Error('不支持的圖片類型');\n    }\n    \n    console.log('發送請求到 remove.bg API');\n    \n    // 發送請求到 remove.bg API\n    const response = await fetch(`${API_BASE_URL}/removebg`, {\n      method: 'POST',\n      headers: {\n        'X-Api-Key': API_KEY\n      },\n      body: formData\n    });\n    \n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error(`API 請求失敗: ${response.status} ${response.statusText}`, errorText);\n      throw new Error(`API 請求失敗: ${response.status} ${response.statusText}`);\n    }\n    \n    console.log('API 請求成功，正在處理響應');\n    \n    // 獲取二進制數據\n    const arrayBuffer = await response.arrayBuffer();\n    \n    // 轉換為 base64\n    const base64 = arrayBufferToBase64(arrayBuffer);\n    \n    console.log('去背處理完成，返回 base64 圖片');\n    \n    return `data:image/png;base64,${base64}`;\n  } catch (error) {\n    console.error('去背 API 調用失敗:', error);\n    throw error;\n  }\n};\n\n/**\n * 將 ArrayBuffer 轉換為 base64 字符串\n * @param {ArrayBuffer} buffer - 要轉換的 ArrayBuffer\n * @returns {string} base64 字符串（不包含 data URL 前綴）\n */\nconst arrayBufferToBase64 = (buffer) => {\n  try {\n    let binary = '';\n    const bytes = new Uint8Array(buffer);\n    const len = bytes.byteLength;\n    \n    for (let i = 0; i < len; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    \n    return window.btoa(binary);\n  } catch (error) {\n    console.error('轉換 ArrayBuffer 到 base64 失敗:', error);\n    throw error;\n  }\n};\n\n\n\n/**\n * 發送批量去背請求到 API\n * @param {Array<File|Blob|string>} images - 圖片文件、Blob 或 URL 的數組\n * @returns {Promise<Array<string>>} 去背後的圖片 Base64 數組\n */\nexport const batchRemoveBackgroundAPI = async (images) => {\n  try {\n    // remove.bg 不直接支持批量處理，所以我們並行處理多個請求\n    // 為了避免同時發送太多請求，我們使用 Promise.all 但限制並行數\n    const batchSize = 3; // 每批處理的圖片數量\n    const results = [];\n    \n    // 分批處理\n    for (let i = 0; i < images.length; i += batchSize) {\n      const batch = images.slice(i, i + batchSize);\n      const batchPromises = batch.map(image => removeBackgroundAPI(image));\n      \n      // 等待當前批次完成\n      const batchResults = await Promise.all(batchPromises);\n      results.push(...batchResults);\n      \n      // 如果還有更多圖片要處理，添加延遲以避免 API 限制\n      if (i + batchSize < images.length) {\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n    }\n    \n    // 返回處理後的圖片 URL 數組\n    return results;\n  } catch (error) {\n    console.error('批量去背 API 調用失敗:', error);\n    throw error;\n  }\n};\n\n/**\n * 發送背景替換請求到 API\n * @param {File|Blob|string} image - 圖片文件、Blob 或 URL\n * @param {File|Blob|string} background - 背景圖片文件、Blob 或 URL\n * @returns {Promise<string>} 處理後的圖片 URL\n */\nexport const replaceBackgroundAPI = async (image, background) => {\n  try {\n    // 首先去除背景\n    const transparentImage = await removeBackgroundAPI(image);\n    \n    // 將透明背景的圖片轉換為 Blob\n    const response = await fetch(transparentImage);\n    const imageBlob = await response.blob();\n    \n    // 使用 Canvas 合成新圖片\n    const compositeImage = await compositeImages(imageBlob, background);\n    \n    return compositeImage;\n  } catch (error) {\n    console.error('背景替換 API 調用失敗:', error);\n    throw error;\n  }\n};\n\n/**\n * 使用 Canvas 將兩張圖片合成\n * @param {Blob} foreground - 前景圖片（已去背）\n * @param {string} background - 背景圖片 URL\n * @returns {Promise<string>} 合成後的圖片 base64 字符串\n */\nconst compositeImages = async (foreground, background) => {\n  return new Promise(async (resolve, reject) => {\n    try {\n      console.log('開始合成圖片...');\n      console.log('前景圖片類型:', typeof foreground);\n      console.log('背景圖片類型:', typeof background);\n      \n      // 創建兩個 Image 對象\n      const fgImage = new Image();\n      const bgImage = new Image();\n      \n      // 設置跨域屬性\n      fgImage.crossOrigin = 'anonymous';\n      bgImage.crossOrigin = 'anonymous';\n      \n      // 加載前景圖片\n      fgImage.onload = () => {\n        console.log('前景圖片加載成功，尺寸:', fgImage.width, 'x', fgImage.height);\n        \n        // 前景加載完成後，加載背景\n        try {\n          if (typeof background === 'string') {\n            if (background.startsWith('data:')) {\n              console.log('加載 data URL 背景');\n              bgImage.src = background;\n            } else if (background.startsWith('http') || background.startsWith('//')) {\n              console.log('加載網絡背景 URL:', background);\n              // 使用代理服務來避免 CORS 問題\n              const proxyUrl = `https://cors-anywhere.herokuapp.com/${background}`;\n              bgImage.src = proxyUrl;\n            } else {\n              console.log('加載本地背景 URL');\n              bgImage.src = background;\n            }\n          } else if (background instanceof Blob || background instanceof File) {\n            console.log('加載 Blob/File 背景');\n            bgImage.src = URL.createObjectURL(background);\n          } else {\n            throw new Error('不支持的背景圖片類型');\n          }\n        } catch (err) {\n          console.error('加載背景圖片時出錯:', err);\n          reject(err);\n        }\n      };\n      \n      // 背景加載完成後，進行合成\n      bgImage.onload = () => {\n        console.log('背景圖片加載成功，尺寸:', bgImage.width, 'x', bgImage.height);\n        \n        try {\n          // 創建 Canvas 元素\n          const canvas = document.createElement('canvas');\n          const ctx = canvas.getContext('2d');\n          \n          // 設置 Canvas 尺寸為前景圖片的尺寸\n          canvas.width = fgImage.width;\n          canvas.height = fgImage.height;\n          console.log('Canvas 尺寸設置為:', canvas.width, 'x', canvas.height);\n          \n          // 繪製背景（調整大小以適應 Canvas）\n          ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);\n          console.log('背景已繪製到 Canvas');\n          \n          // 繪製前景\n          ctx.drawImage(fgImage, 0, 0, canvas.width, canvas.height);\n          console.log('前景已繪製到 Canvas');\n          \n          // 轉換為 base64\n          const result = canvas.toDataURL('image/png');\n          console.log('合成完成，結果長度:', result.length);\n          \n          // 如果背景是 Blob URL，釋放它\n          if (background instanceof Blob || background instanceof File) {\n            URL.revokeObjectURL(bgImage.src);\n          }\n          \n          // 如果前景是 Blob URL，釋放它\n          if (foreground instanceof Blob) {\n            URL.revokeObjectURL(fgImage.src);\n          }\n          \n          resolve(result);\n        } catch (err) {\n          console.error('合成圖片時出錯:', err);\n          reject(err);\n        }\n      };\n      \n      // 設置錯誤處理\n      fgImage.onerror = (err) => {\n        console.error('加載前景圖片失敗:', err);\n        reject(new Error('加載前景圖片失敗'));\n      };\n      \n      bgImage.onerror = (err) => {\n        console.error('加載背景圖片失敗:', err);\n        reject(new Error('加載背景圖片失敗'));\n      };\n      \n      // 開始加載前景\n      try {\n        console.log('開始加載前景圖片...');\n        if (foreground instanceof Blob) {\n          console.log('加載 Blob 前景');\n          fgImage.src = URL.createObjectURL(foreground);\n        } else if (typeof foreground === 'string') {\n          console.log('加載字符串前景:', foreground.substring(0, 50) + '...');\n          fgImage.src = foreground;\n        } else {\n          throw new Error('不支持的前景圖片類型');\n        }\n      } catch (err) {\n        console.error('設置前景圖片時出錯:', err);\n        reject(err);\n      }\n    } catch (error) {\n      console.error('合成圖片過程中出錯:', error);\n      reject(error);\n    }\n  });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}